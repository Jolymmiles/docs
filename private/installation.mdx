---
title: Installation
description: Step-by-step guide to install the Private Version of Remnawave Telegram Shop Bot
---


<Warning>
  **Backup Required**
Before any actions below, make sure to **[backup your database](/private/backup/)** and configuration files.
</Warning>

## Prerequisites

- Linux server or VPS
- Docker and Docker Compose installed
- Domain name with SSL certificate
- Reverse proxy (Caddy or Nginx)
- Remnawave panel installed and configured
- Private version Docker image file (`.tar`)

---

## Installation Options

Choose the installation method based on your setup:

<Tabs>
  <Tab title="Same Server as Remnawave">
    
### Installation Alongside Remnawave Panel

Use this method if the bot will run on the **same server** as your Remnawave panel. The bot connects to Remnawave via Docker's internal network.

<Steps>

  <Step title="Create project directory">
  ```bash
  mkdir -p /opt/rwp-shop
  cd /opt/rwp-shop
  ```
  </Step>
  <Step title="Load Docker image">

  Download the image file from [me.remnawavebot.dev/releases](https://me.remnawavebot.dev/releases).

  ```bash
  docker load -i rwp_shop-<VERSION>.tar
  ```
  </Step>
  <Step title="Create required directories">
  ```bash
  mkdir -p uploads translations
  sudo chmod -R 777 uploads translations
  ```
  </Step>
  <Step title="Download translation files">

  Download `en.json` and `ru.json` from the private channel and place them in the `translations` folder:
  ```bash
  # Copy downloaded files to translations directory
  cp en.json ru.json ./translations/
  ```
  </Step>
  <Step title="Create Docker Compose configuration">
  ```bash
  nano compose.yaml
  ```

  ```yaml
  name: rwp_shop

  services:
    bot:
      image: rwp_shop:<VERSION>
      container_name: rwp_shop
      restart: unless-stopped
      ports:
        - "127.0.0.1:9912:8080"
      depends_on:
        db:
          condition: service_healthy
      volumes:
        - ./translations:/translations
        - ./uploads:/uploads
        - /etc/machine-id:/etc/machine-id:ro
      environment:
        - REMNAWAVE_URL=${REMNAWAVE_URL}
        - REMNAWAVE_TOKEN=${REMNAWAVE_TOKEN}
        - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
        - ADMIN_TELEGRAM_ID=${ADMIN_TELEGRAM_ID}
        - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable
        - BOT_ADMIN_URL=${BOT_ADMIN_URL}
        - LOG_LEVEL=${LOG_LEVEL:-info}
        - ACCESS_LOG_ENABLED=${ACCESS_LOG_ENABLED:-true}
        - ACCESS_LOG_PATH=${ACCESS_LOG_PATH:-}
        - LICENSE_KEY=${LICENSE_KEY:-}
        - REMNAWAVE_HEADERS=${REMNAWAVE_HEADERS:-}
      networks:
        - remnawave-network

    db:
      image: postgres:17-alpine
      container_name: rwp_shop_db
      restart: unless-stopped
      environment:
        - POSTGRES_USER=${POSTGRES_USER}
        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        - POSTGRES_DB=${POSTGRES_DB}
        - TZ=UTC
      ports:
        - "127.0.0.1:9999:5432"
      volumes:
        - rwp_shop_db_data:/var/lib/postgresql/data
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
        interval: 3s
        timeout: 10s
        retries: 3
      networks:
        - remnawave-network

  volumes:
    rwp_shop_db_data:

  networks:
    remnawave-network:
      name: remnawave-network
      external: true
  ```

  <Note>
  The `remnawave-network` is created by the Remnawave panel. Setting `external: true` connects to this existing network.
  </Note>
  </Step>
  <Step title="Create environment file">
  ```bash
  nano .env
  ```

  ```bash
  # Remnawave Connection (internal Docker network)
  REMNAWAVE_URL=http://remnawave:3000
  REMNAWAVE_TOKEN=your_remnawave_api_token

  # Telegram
  TELEGRAM_TOKEN=your_telegram_bot_token
  ADMIN_TELEGRAM_ID=123456789,987654321

  # Database
  POSTGRES_USER=postgres
  POSTGRES_PASSWORD=postgres
  POSTGRES_DB=postgres

  # Admin Panel URL (HTTPS required)
  BOT_ADMIN_URL=https://bot.example.com

  # Logging (optional)
  # LOG_LEVEL=info
  # ACCESS_LOG_ENABLED=true
  # ACCESS_LOG_PATH=

  LICENSE_KEY=

  # Custom headers for Remnawave API (optional)
  # REMNAWAVE_HEADERS=
  ```

  <Tip>
  `REMNAWAVE_URL=http://remnawave:3000` uses the container name from Remnawave's Docker network.
  </Tip>

  <Tip>
    **Remnawave Reverse-Proxy (egames)**
  If you use [Remnawave Reverse-Proxy by egames](https://wiki.egam.es/), add a cookie for authentication:
  ```bash
  REMNAWAVE_HEADERS=Cookie:rEmnaprx=aBCDefgh
  ```
  How to get the cookie: [instructions](https://wiki.egam.es/ru/troubleshooting/common-issues/#утерянный-cookie-пути-к-панели)
  </Tip>

  <Note>
    **Logging Variables**
  - `LOG_LEVEL` — logging level (debug, info, warn, error)
  - `ACCESS_LOG_ENABLED` — enable/disable access logs (true/false)
  - `ACCESS_LOG_PATH` — path to log file; if not set, logs are written to console
  </Note>

  <Warning>
    **License Key**
  `LICENSE_KEY` is required for the bot to work. You can get it from your personal dashboard at the license server after purchasing a subscription.
  </Warning>
  </Step>
  <Step title="Add machine-id volume for license">

  The license is bound to your server's unique identifier. Add this volume to `compose.yaml` in the `bot` service:
  ```yaml
  volumes:
    - ./translations:/translations
    - ./uploads:/uploads
    - /etc/machine-id:/etc/machine-id:ro
  ```

  <Note>
  This ensures the license remains valid even when the container is recreated.
  </Note>
  </Step>
  <Step title="Start the bot">
  ```bash
  docker compose up -d
  ```
  </Step>
</Steps>

  </Tab>
  <Tab title="Separate Server">

### Installation on Separate Server

Use this method if the bot will run on a **different server** from your Remnawave panel. The bot connects to Remnawave via external HTTPS URL.

<Steps>

  <Step title="Create project directory">
  ```bash
  mkdir -p /opt/rwp-shop
  cd /opt/rwp-shop
  ```
  </Step>
  <Step title="Load Docker image">

  Download the image file from [me.remnawavebot.dev/releases](https://me.remnawavebot.dev/releases).

  ```bash
  docker load -i rwp_shop-<VERSION>.tar
  ```
  </Step>
  <Step title="Create required directories">
  ```bash
  mkdir -p uploads translations
  sudo chmod -R 777 uploads translations
  ```
  </Step>
  <Step title="Download translation files">

  Download `en.json` and `ru.json` from the private channel and place them in the `translations` folder:
  ```bash
  # Copy downloaded files to translations directory
  cp en.json ru.json ./translations/
  ```
  </Step>
  <Step title="Create Docker Compose configuration">
  ```bash
  nano compose.yaml
  ```

  ```yaml
  name: rwp_shop

  services:
    bot:
      image: rwp_shop:<VERSION>
      container_name: rwp_shop
      restart: unless-stopped
      ports:
        - "127.0.0.1:9912:8080"
      depends_on:
        db:
          condition: service_healthy
      volumes:
        - ./translations:/translations
        - ./uploads:/uploads
        - /etc/machine-id:/etc/machine-id:ro
      environment:
        - REMNAWAVE_URL=${REMNAWAVE_URL}
        - REMNAWAVE_TOKEN=${REMNAWAVE_TOKEN}
        - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
        - ADMIN_TELEGRAM_ID=${ADMIN_TELEGRAM_ID}
        - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable
        - BOT_ADMIN_URL=${BOT_ADMIN_URL}
        - LOG_LEVEL=${LOG_LEVEL:-info}
        - ACCESS_LOG_ENABLED=${ACCESS_LOG_ENABLED:-true}
        - ACCESS_LOG_PATH=${ACCESS_LOG_PATH:-}
        - LICENSE_KEY=${LICENSE_KEY:-}
        - REMNAWAVE_HEADERS=${REMNAWAVE_HEADERS:-}

    db:
      image: postgres:17-alpine
      container_name: rwp_shop_db
      restart: unless-stopped
      environment:
        - POSTGRES_USER=${POSTGRES_USER}
        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        - POSTGRES_DB=${POSTGRES_DB}
        - TZ=UTC
      ports:
        - "127.0.0.1:9999:5432"
      volumes:
        - rwp_shop_db_data:/var/lib/postgresql/data
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
        interval: 3s
        timeout: 10s
        retries: 3

  volumes:
    rwp_shop_db_data:
  ```
  </Step>
  <Step title="Create environment file">
  ```bash
  nano .env
  ```

  ```bash
  # Remnawave Connection (external HTTPS URL)
  REMNAWAVE_URL=https://panel.example.com
  REMNAWAVE_TOKEN=your_remnawave_api_token

  # Telegram
  TELEGRAM_TOKEN=your_telegram_bot_token
  ADMIN_TELEGRAM_ID=123456789,987654321

  # Database
  POSTGRES_USER=postgres
  POSTGRES_PASSWORD=postgres
  POSTGRES_DB=postgres

  # Admin Panel URL (HTTPS required)
  BOT_ADMIN_URL=https://bot.example.com

  # Logging (optional)
  # LOG_LEVEL=info
  # ACCESS_LOG_ENABLED=true
  # ACCESS_LOG_PATH=

  LICENSE_KEY=

  # Custom headers for Remnawave API (optional)
  # REMNAWAVE_HEADERS=
  ```

  <Warning>
  `REMNAWAVE_URL` must be the **external HTTPS URL** of your Remnawave panel (e.g., `https://panel.example.com`).
  </Warning>

  <Tip>
    **Remnawave Reverse-Proxy (egames)**
  If you use [Remnawave Reverse-Proxy by egames](https://wiki.egam.es/), add a cookie for authentication:
  ```bash
  REMNAWAVE_HEADERS=Cookie:rEmnaprx=aBCDefgh
  ```
  How to get the cookie: [instructions](https://wiki.egam.es/ru/troubleshooting/common-issues/#утерянный-cookie-пути-к-панели)
  </Tip>

  <Note>
    **Logging Variables**
  - `LOG_LEVEL` — logging level (debug, info, warn, error)
  - `ACCESS_LOG_ENABLED` — enable/disable access logs (true/false)
  - `ACCESS_LOG_PATH` — path to log file; if not set, logs are written to console
  </Note>

  <Warning>
    **License Key**
  `LICENSE_KEY` is required for the bot to work. You can get it from your personal dashboard at the license server after purchasing a subscription.
  </Warning>
  </Step>
  <Step title="Add machine-id volume for license">

  The license is bound to your server's unique identifier. Add this volume to `compose.yaml` in the `bot` service:
  ```yaml
  volumes:
    - ./translations:/translations
    - ./uploads:/uploads
    - /etc/machine-id:/etc/machine-id:ro
  ```

  <Note>
  This ensures the license remains valid even when the container is recreated.
  </Note>
  </Step>
  <Step title="Start the bot">
  ```bash
  docker compose up -d
  ```
  </Step>
</Steps>

  </Tab>
</Tabs>

---

## Configure Reverse Proxy

<Note>
  **Caching**
The configurations below include caching rules to protect Mini App from loading errors after updates:
- HTML files are not cached (always up-to-date version)
- Static resources `/assets/` are cached for one year (have unique hashes)
</Note>

<Warning>
  **For Separate Server**
The examples below are for **system-wide installation** of Caddy/Nginx (via systemd). If you run Caddy/Nginx in a Docker container, you need to either put them in the same Docker network and hide the ports, or use `host.docker.internal` instead of `127.0.0.1`.
</Warning>

<Tabs>
  <Tab title="Caddy">
    Add to your Caddyfile:
    ```txt
    (security_headers) {
        header * {
            Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
            X-Content-Type-Options "nosniff"
            -X-Frame-Options
            Content-Security-Policy "frame-ancestors 'self' https://web.telegram.org https://webk.telegram.org https://webz.telegram.org https://*.telegram.org"
            X-XSS-Protection "1; mode=block"
            -Server
            Referrer-Policy strict-origin-when-cross-origin
            X-Robots-Tag "noindex, nofollow"
        }
    }

    bot.example.com {
        import security_headers

        @html path_regexp \.html$|^/$
        header @html Cache-Control "no-cache, no-store, must-revalidate"
        
        @assets_js path /assets/*.js
        header @assets_js Cache-Control "no-cache, no-store, must-revalidate"
        
        @immutable {
            path /assets/*
            not path *.js
        }
        header @immutable Cache-Control "public, max-age=31536000, immutable"
        
        reverse_proxy 127.0.0.1:9912
    }
```
    
    Restart Caddy:
    ```bash
    sudo systemctl reload caddy
    ```
  </Tab>
  <Tab title="Nginx">
    Create config file:
    ```bash
    sudo nano /etc/nginx/sites-available/bot.example.com
    ```
    
    ```nginx
    server {
        listen 80;
        server_name bot.example.com;
        add_header Content-Security-Policy "frame-ancestors 'self' https://web.telegram.org https://webk.telegram.org https://webz.telegram.org https://*.telegram.org" always;
        proxy_hide_header X-Frame-Options;

        location ~* \.html$ {
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location ~* ^/assets/.*\.js$ {
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /assets/ {
            add_header Cache-Control "public, max-age=31536000, immutable" always;
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location / {
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            client_max_body_size 50M;
        }
    }
```
    
    Enable and restart:
    ```bash
    sudo ln -s /etc/nginx/sites-available/bot.example.com /etc/nginx/sites-enabled/
    sudo nginx -t
    sudo systemctl reload nginx
    ```
  </Tab>
</Tabs>

---

## Verify Installation

```bash
docker compose logs -f bot
```

---

Need access logs with rotation? See [Access logs with rotation](/private/access-logs/).

Need direct links? See [Browser login (direct links)](/private/direct-links/).


Need S3-compatible storage? See [S3 storage setup](/private/s3/).

## Port Reference

| Service | Internal Port | Recommended External |
|---------|---------------|---------------------|
| Bot HTTP | 8080 | 9912 or 12345 |
| PostgreSQL | 5432 | - |

---

## Post-Installation

After installation:

1. Open `https://bot.example.com` in Telegram Mini App
2. Log in with your admin Telegram account
3. Configure settings in the admin panel:
   - Payment systems
   - Subscription plans
   - Branding
   - Roles and permissions

All other settings are managed through the **Admin Panel UI**.

---

## Tips

<Tip>
  **Having issues?**
See the [Troubleshooting](/private/troubleshooting/) page for solutions to common problems.
</Tip>

### Add Menu Button in Telegram

To add an "Open" button in Telegram that opens the user dashboard instead of typing commands:

1. Open [@BotFather](https://t.me/BotFather)
2. Select your bot
3. Go to **Bot Settings** → **Menu Button**
4. Set the URL to your dashboard:
   ```
   https://bot.example.com
   ```

This will add a button in the Telegram chat that opens the Mini App with the user's personal dashboard.

### Configure Mini App Button

To add your Mini App as a button that appears when users tap the menu icon or type `/start`:

1. Open [@BotFather](https://t.me/BotFather)
2. Send the command `/newapp`
3. Select your bot from the list
4. Follow the prompts:
   - **Title**: Enter the app name (e.g., "Dashboard")
   - **Description**: Brief description of the app
   - **Photo**: Upload a 640x360 image for the app preview
   - **GIF** (optional): Upload a demo animation
   - **Web App URL**: Enter your dashboard URL (e.g., `https://bot.example.com`)
5. After creation, send `/myapps` to manage your Mini Apps

<Tip>
You can also use `/setmenubutton` to configure the menu button directly without creating a full Mini App entry.
</Tip>


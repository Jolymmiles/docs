---
title: Installation
description: Step-by-step guide to install the Private Version of Remnawave Telegram Shop Bot
---


<Warning>
  **Backup Required**
Before any actions below, make sure to **[backup your database](/private/backup/)** and configuration files.
</Warning>

## Prerequisites

- Linux server or VPS
- Docker and Docker Compose installed
- Domain name with SSL certificate
- Reverse proxy (Caddy or Nginx)
- Remnawave panel installed and configured
- Private version Docker image file (`.tar`)

---

## Installation Options

Choose the installation method based on your setup:

<Tabs>
  <Tab title="Same Server as Remnawave">
    
### Installation Alongside Remnawave Panel

Use this method if the bot will run on the **same server** as your Remnawave panel. The bot connects to Remnawave via Docker's internal network.

<Steps>

  <Step title="Create project directory">
  ```bash
  mkdir -p /opt/private-remnawave-telegram-shop-bot
  cd /opt/private-remnawave-telegram-shop-bot
  ```
  </Step>
  <Step title="Load Docker image">

  Download the image file from the private channel.

  ```bash
  docker load -i rwp_shop-<VERSION>.tar
  ```
  </Step>
  <Step title="Create required directories">
  ```bash
  mkdir -p uploads translations
  sudo chmod -R 777 uploads translations
  ```
  </Step>
  <Step title="Download translation files">

  Download `en.json` and `ru.json` from the private channel and place them in the `translations` folder:
  ```bash
  # Copy downloaded files to translations directory
  cp en.json ru.json ./translations/
  ```
  </Step>
  <Step title="Create Docker Compose configuration">
  ```bash
  nano compose.yaml
  ```

  ```yaml
  name: rwp_shop

  services:
    bot:
      image: rwp_shop:<VERSION>
      container_name: rwp_shop
      restart: unless-stopped
      ports:
        - "127.0.0.1:9912:8080"
      depends_on:
        db:
          condition: service_healthy
      volumes:
        - ./translations:/translations
        - ./uploads:/uploads
        - /etc/machine-id:/etc/machine-id:ro
      environment:
        - REMNAWAVE_URL=${REMNAWAVE_URL}
        - REMNAWAVE_TOKEN=${REMNAWAVE_TOKEN}
        - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
        - ADMIN_TELEGRAM_ID=${ADMIN_TELEGRAM_ID}
        - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable
        - BOT_ADMIN_URL=${BOT_ADMIN_URL}
        - LOG_LEVEL=${LOG_LEVEL:-info}
        - ACCESS_LOG_ENABLED=${ACCESS_LOG_ENABLED:-true}
        - ACCESS_LOG_PATH=${ACCESS_LOG_PATH:-}
        - LICENSE_KEY=${LICENSE_KEY:-}
        - REMNAWAVE_HEADERS=${REMNAWAVE_HEADERS:-}
      networks:
        - remnawave-network

    db:
      image: postgres:17-alpine
      container_name: rwp_shop_db
      restart: unless-stopped
      environment:
        - POSTGRES_USER=${POSTGRES_USER}
        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        - POSTGRES_DB=${POSTGRES_DB}
        - TZ=UTC
      ports:
        - "127.0.0.1:9999:5432"
      volumes:
        - rwp_shop_db_data:/var/lib/postgresql/data
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
        interval: 3s
        timeout: 10s
        retries: 3
      networks:
        - remnawave-network

  volumes:
    rwp_shop_db_data:

  networks:
    remnawave-network:
      name: remnawave-network
      external: true
  ```

  <Note>
  The `remnawave-network` is created by the Remnawave panel. Setting `external: true` connects to this existing network.
  </Note>
  </Step>
  <Step title="Create environment file">
  ```bash
  nano .env
  ```

  ```bash
  # Remnawave Connection (internal Docker network)
  REMNAWAVE_URL=http://remnawave:3000
  REMNAWAVE_TOKEN=your_remnawave_api_token

  # Telegram
  TELEGRAM_TOKEN=your_telegram_bot_token
  ADMIN_TELEGRAM_ID=123456789,987654321

  # Database
  POSTGRES_USER=postgres
  POSTGRES_PASSWORD=postgres
  POSTGRES_DB=postgres

  # Admin Panel URL (HTTPS required)
  BOT_ADMIN_URL=https://bot.example.com

  # Logging (optional)
  # LOG_LEVEL=info
  # ACCESS_LOG_ENABLED=true
  # ACCESS_LOG_PATH=

  LICENSE_KEY=

  # Custom headers for Remnawave API (optional)
  # REMNAWAVE_HEADERS=
  ```

  <Tip>
  `REMNAWAVE_URL=http://remnawave:3000` uses the container name from Remnawave's Docker network.
  </Tip>

  <Tip>
    **Remnawave Reverse-Proxy (egames)**
  If you use [Remnawave Reverse-Proxy by egames](https://wiki.egam.es/), add a cookie for authentication:
  ```bash
  REMNAWAVE_HEADERS=Cookie:rEmnaprx=aBCDefgh
  ```
  How to get the cookie: [instructions](https://wiki.egam.es/ru/troubleshooting/common-issues/#утерянный-cookie-пути-к-панели)
  </Tip>

  <Note>
    **Logging Variables**
  - `LOG_LEVEL` — logging level (debug, info, warn, error)
  - `ACCESS_LOG_ENABLED` — enable/disable access logs (true/false)
  - `ACCESS_LOG_PATH` — path to log file; if not set, logs are written to console
  </Note>

  <Warning>
    **License Key**
  `LICENSE_KEY` is required for the bot to work. You can get it from your personal dashboard at the license server after purchasing a subscription.
  </Warning>
  </Step>
  <Step title="Add machine-id volume for license">

  The license is bound to your server's unique identifier. Add this volume to `compose.yaml` in the `bot` service:
  ```yaml
  volumes:
    - ./translations:/translations
    - ./uploads:/uploads
    - /etc/machine-id:/etc/machine-id:ro
  ```

  <Note>
  This ensures the license remains valid even when the container is recreated.
  </Note>
  </Step>
  <Step title="Start the bot">
  ```bash
  docker compose up -d
  ```
  </Step>
</Steps>

  </Tab>
  <Tab title="Separate Server">

### Installation on Separate Server

Use this method if the bot will run on a **different server** from your Remnawave panel. The bot connects to Remnawave via external HTTPS URL.

<Steps>

  <Step title="Create project directory">
  ```bash
  mkdir -p /opt/private-remnawave-telegram-shop-bot
  cd /opt/private-remnawave-telegram-shop-bot
  ```
  </Step>
  <Step title="Load Docker image">

  Download the image file from the private channel.

  ```bash
  docker load -i rwp_shop-<VERSION>.tar
  ```
  </Step>
  <Step title="Create required directories">
  ```bash
  mkdir -p uploads translations
  sudo chmod -R 777 uploads translations
  ```
  </Step>
  <Step title="Download translation files">

  Download `en.json` and `ru.json` from the private channel and place them in the `translations` folder:
  ```bash
  # Copy downloaded files to translations directory
  cp en.json ru.json ./translations/
  ```
  </Step>
  <Step title="Create Docker Compose configuration">
  ```bash
  nano compose.yaml
  ```

  ```yaml
  name: rwp_shop

  services:
    bot:
      image: rwp_shop:<VERSION>
      container_name: rwp_shop
      restart: unless-stopped
      ports:
        - "127.0.0.1:9912:8080"
      depends_on:
        db:
          condition: service_healthy
      volumes:
        - ./translations:/translations
        - ./uploads:/uploads
        - /etc/machine-id:/etc/machine-id:ro
      environment:
        - REMNAWAVE_URL=${REMNAWAVE_URL}
        - REMNAWAVE_TOKEN=${REMNAWAVE_TOKEN}
        - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
        - ADMIN_TELEGRAM_ID=${ADMIN_TELEGRAM_ID}
        - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable
        - BOT_ADMIN_URL=${BOT_ADMIN_URL}
        - LOG_LEVEL=${LOG_LEVEL:-info}
        - ACCESS_LOG_ENABLED=${ACCESS_LOG_ENABLED:-true}
        - ACCESS_LOG_PATH=${ACCESS_LOG_PATH:-}
        - LICENSE_KEY=${LICENSE_KEY:-}
        - REMNAWAVE_HEADERS=${REMNAWAVE_HEADERS:-}

    db:
      image: postgres:17-alpine
      container_name: rwp_shop_db
      restart: unless-stopped
      environment:
        - POSTGRES_USER=${POSTGRES_USER}
        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        - POSTGRES_DB=${POSTGRES_DB}
        - TZ=UTC
      ports:
        - "127.0.0.1:9999:5432"
      volumes:
        - rwp_shop_db_data:/var/lib/postgresql/data
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
        interval: 3s
        timeout: 10s
        retries: 3

  volumes:
    rwp_shop_db_data:
  ```
  </Step>
  <Step title="Create environment file">
  ```bash
  nano .env
  ```

  ```bash
  # Remnawave Connection (external HTTPS URL)
  REMNAWAVE_URL=https://panel.example.com
  REMNAWAVE_TOKEN=your_remnawave_api_token

  # Telegram
  TELEGRAM_TOKEN=your_telegram_bot_token
  ADMIN_TELEGRAM_ID=123456789,987654321

  # Database
  POSTGRES_USER=postgres
  POSTGRES_PASSWORD=postgres
  POSTGRES_DB=postgres

  # Admin Panel URL (HTTPS required)
  BOT_ADMIN_URL=https://bot.example.com

  # Logging (optional)
  # LOG_LEVEL=info
  # ACCESS_LOG_ENABLED=true
  # ACCESS_LOG_PATH=

  LICENSE_KEY=

  # Custom headers for Remnawave API (optional)
  # REMNAWAVE_HEADERS=
  ```

  <Warning>
  `REMNAWAVE_URL` must be the **external HTTPS URL** of your Remnawave panel (e.g., `https://panel.example.com`).
  </Warning>

  <Tip>
    **Remnawave Reverse-Proxy (egames)**
  If you use [Remnawave Reverse-Proxy by egames](https://wiki.egam.es/), add a cookie for authentication:
  ```bash
  REMNAWAVE_HEADERS=Cookie:rEmnaprx=aBCDefgh
  ```
  How to get the cookie: [instructions](https://wiki.egam.es/ru/troubleshooting/common-issues/#утерянный-cookie-пути-к-панели)
  </Tip>

  <Note>
    **Logging Variables**
  - `LOG_LEVEL` — logging level (debug, info, warn, error)
  - `ACCESS_LOG_ENABLED` — enable/disable access logs (true/false)
  - `ACCESS_LOG_PATH` — path to log file; if not set, logs are written to console
  </Note>

  <Warning>
    **License Key**
  `LICENSE_KEY` is required for the bot to work. You can get it from your personal dashboard at the license server after purchasing a subscription.
  </Warning>
  </Step>
  <Step title="Add machine-id volume for license">

  The license is bound to your server's unique identifier. Add this volume to `compose.yaml` in the `bot` service:
  ```yaml
  volumes:
    - ./translations:/translations
    - ./uploads:/uploads
    - /etc/machine-id:/etc/machine-id:ro
  ```

  <Note>
  This ensures the license remains valid even when the container is recreated.
  </Note>
  </Step>
  <Step title="Start the bot">
  ```bash
  docker compose up -d
  ```
  </Step>
</Steps>

  </Tab>
</Tabs>

---

## Configure Reverse Proxy

<Note>
  **Caching**
The configurations below include caching rules to protect Mini App from loading errors after updates:
- HTML files are not cached (always up-to-date version)
- Static resources `/assets/` are cached for one year (have unique hashes)
</Note>

<Warning>
  **For Separate Server**
The examples below are for **system-wide installation** of Caddy/Nginx (via systemd). If you run Caddy/Nginx in a Docker container, you need to either put them in the same Docker network and hide the ports, or use `host.docker.internal` instead of `127.0.0.1`.
</Warning>

<Tabs>
  <Tab title="Caddy">
    Add to your Caddyfile:
    ```txt
    (security_headers) {
        header * {
            Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
            X-Content-Type-Options "nosniff"
            X-Frame-Options "SAMEORIGIN"
            X-XSS-Protection "1; mode=block"
            -Server
            Referrer-Policy strict-origin-when-cross-origin
            X-Robots-Tag "noindex, nofollow"
        }
    }

    bot.example.com {
        import security_headers

        @html path_regexp \.html$|^/$
        header @html Cache-Control "no-cache, no-store, must-revalidate"
        
        @assets_js path /assets/*.js
        header @assets_js Cache-Control "no-cache, no-store, must-revalidate"
        
        @immutable {
            path /assets/*
            not path *.js
        }
        header @immutable Cache-Control "public, max-age=31536000, immutable"
        
        reverse_proxy 127.0.0.1:9912
    }
```
    
    Restart Caddy:
    ```bash
    sudo systemctl reload caddy
    ```
  </Tab>
  <Tab title="Nginx">
    Create config file:
    ```bash
    sudo nano /etc/nginx/sites-available/bot.example.com
    ```
    
    ```nginx
    server {
        listen 80;
        server_name bot.example.com;

        location ~* \.html$ {
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location ~* ^/assets/.*\.js$ {
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /assets/ {
            add_header Cache-Control "public, max-age=31536000, immutable" always;
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location / {
            proxy_pass http://127.0.0.1:9912;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            client_max_body_size 50M;
        }
    }
```
    
    Enable and restart:
    ```bash
    sudo ln -s /etc/nginx/sites-available/bot.example.com /etc/nginx/sites-enabled/
    sudo nginx -t
    sudo systemctl reload nginx
    ```
  </Tab>
</Tabs>

### Windows URL Scheme Redirect (Optional)

For Windows users, custom URL schemes (like `happ://`, `v2ray://`, `clash://`) may not open directly from Telegram. Add a `/redir` endpoint to handle these redirects:

<Tabs>
  <Tab title="Caddy">
    Add inside your domain block, **before** `reverse_proxy`:
    ```txt
@redir {
    path /redir
    expression {http.request.uri.query} != ""
}

route @redir {
    uri replace + %2B

    redir {query.url} 302
}
```
    
    Full example:
    ```txt
    bot.example.com {
        import security_headers

        @redir {
            path /redir
            expression {http.request.uri.query} != ""
        }

        route @redir {
            uri replace + %2B

            redir {query.url} 302
        }
        
        # ... rest of configuration
        reverse_proxy 127.0.0.1:9912
    }
```
  </Tab>
  <Tab title="Nginx">
    Add inside `server` block:
    ```nginx
    location = /redir {
        if ($arg_url) {
            return 302 $arg_url;
        }
        return 400;
    }
```
  </Tab>
</Tabs>

<Note>
This allows the Mini App to redirect Windows users through `https://bot.example.com/redir?url=happ://...` which then performs a 302 redirect to the custom URL scheme.
</Note>

---

## Verify Installation

```bash
docker compose logs -f bot
```

---

## Access Logs with Rotation

To write access logs to a file with automatic rotation:

<Steps>

  <Step title="Create logs directory">
  ```bash
  mkdir -p logs
  sudo chmod 777 logs
  ```
  </Step>
  <Step title="Add volume to compose.yaml">

  In the `bot` service section, add:
  ```yaml
  volumes:
    - ./translations:/translations
    - ./uploads:/uploads
    - ./logs:/logs
  ```
  </Step>
  <Step title="Set log path in .env">
  ```bash
  ACCESS_LOG_PATH=/logs/access.log
  ```
  </Step>
  <Step title="Restart the bot">
  ```bash
  docker compose up -d
  ```
  </Step>
  <Step title="Install logrotate">
  (if not installed)
  ```bash
  # Debian/Ubuntu
  sudo apt update && sudo apt install -y logrotate

  # CentOS/RHEL/Fedora
  sudo dnf install -y logrotate
  ```
  </Step>
  <Step title="Create logrotate config">
  ```bash
  sudo nano /etc/logrotate.d/rwp-shop
  ```

  ```txt
  /opt/private-remnawave-telegram-shop-bot/logs/access.log {
      daily
      rotate 14
      compress
      delaycompress
      missingok
      notifempty
      copytruncate
  }
  ```

  <Note>
  Replace `/opt/private-remnawave-telegram-shop-bot/logs/access.log` with your actual installation path.
  </Note>
  </Step>
  <Step title="Verify configuration">
  ```bash
  sudo logrotate -d /etc/logrotate.d/rwp-shop
  ```

  The `-d` flag runs in debug mode without actual rotation.
  </Step>
  <Step title="Test rotation">
  ```bash
  sudo logrotate -f /etc/logrotate.d/rwp-shop
  ```

  The `-f` flag forces rotation.
  </Step>
</Steps>

<Tip>
`copytruncate` allows rotating logs without restarting the container — the file is truncated in place after copying.
</Tip>

<Note>
  **Automatic Execution**
Logrotate usually runs automatically via cron or systemd timer (daily). You can check:
```bash
# For systemd
systemctl status logrotate.timer

# For cron
cat /etc/cron.daily/logrotate
```
</Note>

| Parameter | Description |
|-----------|-------------|
| `daily` | Rotate daily |
| `rotate 14` | Keep 14 archives |
| `compress` | Compress archives with gzip |
| `delaycompress` | Compress starting from second archive |
| `missingok` | Don't error if file is missing |
| `notifempty` | Don't rotate empty file |
| `copytruncate` | Copy and truncate without restart |

---

## S3 Storage (Optional)

By default, uploaded files (support attachments, FAQ images, partner files) are stored locally in the `./uploads` directory. You can optionally use S3-compatible storage (MinIO, RustFS, AWS S3, etc.) for better scalability and reliability.

<Steps>

  <Step title="Add S3 environment variables to .env">
  ```bash
  # S3 Storage (optional)
  S3_ENABLED=true
  S3_ENDPOINT=http://rustfs:9000
  S3_ACCESS_KEY=your_access_key
  S3_SECRET_KEY=your_secret_key
  S3_PUBLIC_URL=https://s3.example.com
  ```
  </Step>
  <Step title="Add S3 service to compose.yaml">
  (if using RustFS)
  ```yaml
  rustfs:
    image: ghcr.io/rustfs/rustfs:latest
    container_name: rwp_shop_rustfs
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      - RUSTFS_ROOT_USER=your_access_key
      - RUSTFS_ROOT_PASSWORD=your_secret_key
    volumes:
      - rustfs_data:/data
    ports:
      - "127.0.0.1:9001:9001"
    networks:
      - remnawave-network
  ```

  Add volume:
  ```yaml
  volumes:
    rwp_shop_db_data:
    rustfs_data:
  ```
  </Step>
  <Step title="Configure reverse proxy for S3">

  Add subdomain for S3 public access (required for presigned URLs):

  <Tabs>
    <Tab title="Caddy">
      ```
      s3.example.com {
          import security_headers
          reverse_proxy rustfs:9000
      }
  ```
    </Tab>
    <Tab title="Nginx">
      ```nginx
      server {
          listen 443 ssl http2;
          server_name s3.example.com;

          location / {
              proxy_pass http://127.0.0.1:9000;
              proxy_set_header Host $host;
              client_max_body_size 100M;
          }
      }
  ```
    </Tab>
  </Tabs>
  </Step>
  <Step title="Restart the bot">
  ```bash
  docker compose up -d
  ```
  </Step>
</Steps>

<Note>
  **Environment Variables**
| Variable | Description |
|----------|-------------|
| `S3_ENABLED` | Enable S3 storage (`true`/`false`) |
| `S3_ENDPOINT` | Internal S3 endpoint (for Docker: `http://rustfs:9000`) |
| `S3_ACCESS_KEY` | S3 access key |
| `S3_SECRET_KEY` | S3 secret key |
| `S3_PUBLIC_URL` | Public HTTPS URL for presigned URLs |
</Note>

<Warning>
  **S3_PUBLIC_URL Required**
`S3_PUBLIC_URL` must be set to a publicly accessible HTTPS URL. This is used for generating presigned URLs that allow direct file downloads from S3.
</Warning>

---

## Port Reference

| Service | Internal Port | Recommended External |
|---------|---------------|---------------------|
| Bot HTTP | 8080 | 9912 or 12345 |
| PostgreSQL | 5432 | - |

---

## Post-Installation

After installation:

1. Open `https://bot.example.com` in Telegram Mini App
2. Log in with your admin Telegram account
3. Configure settings in the admin panel:
   - Payment systems
   - Subscription plans
   - Branding
   - Roles and permissions

All other settings are managed through the **Admin Panel UI**.

---

## Tips

<Tip>
  **Having issues?**
See the [Troubleshooting](/private/troubleshooting/) page for solutions to common problems.
</Tip>

### Add Menu Button in Telegram

To add an "Open" button in Telegram that opens the user dashboard instead of typing commands:

1. Open [@BotFather](https://t.me/BotFather)
2. Select your bot
3. Go to **Bot Settings** → **Menu Button**
4. Set the URL to your dashboard:
   ```
   https://bot.example.com
   ```

This will add a button in the Telegram chat that opens the Mini App with the user's personal dashboard.

### Configure Mini App Button

To add your Mini App as a button that appears when users tap the menu icon or type `/start`:

1. Open [@BotFather](https://t.me/BotFather)
2. Send the command `/newapp`
3. Select your bot from the list
4. Follow the prompts:
   - **Title**: Enter the app name (e.g., "Dashboard")
   - **Description**: Brief description of the app
   - **Photo**: Upload a 640x360 image for the app preview
   - **GIF** (optional): Upload a demo animation
   - **Web App URL**: Enter your dashboard URL (e.g., `https://bot.example.com`)
5. After creation, send `/myapps` to manage your Mini Apps

<Tip>
You can also use `/setmenubutton` to configure the menu button directly without creating a full Mini App entry.
</Tip>

### Configure Web Login (Direct Links)

To allow users to open your Mini App directly in a browser via `t.me` links (without using Telegram's in-app browser), you need to configure the domain in BotFather:

1. Open [@BotFather](https://t.me/BotFather)
2. Send the command `/setdomain`
3. Select your bot from the list
4. Enter the domain from your admin panel (e.g., `bot.example.com`)

<Note>
The domain must match the `BOT_ADMIN_URL` value (without the `https://` prefix).
</Note>

After this configuration, users can access the Mini App via direct browser links.
